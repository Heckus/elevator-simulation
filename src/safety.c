#define _XOPEN_SOURCE 700
#include <signal.h>

#include <stdlib.h>
#include <string.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <ctype.h>
#include <unistd.h>
#include <fcntl.h>

#include "sharedmemory.h"

/**
 This code adheres to the following MISRA C guidelines:
 
 1. Rule 1.1: The code conforms to ISO C90 standard.
    - The code uses standard C90 syntax and constructs.
 
 2. Rule 2.1: All code is traceable to documented requirements.
    - Each function and variable is clearly named and documented, ensuring traceability.

 3. Rule 8.1: Functions are declared and defined with appropriate prototypes.
    - All functions have proper declarations and definitions with matching prototypes.
 
 4. Rule 10.1: Implicit conversions are avoided.
    - The code avoids implicit type conversions by using explicit casting where necessary.
 
 5. Rule 17.4: Array indexing is within bounds.
    - All array accesses are checked to ensure they are within valid bounds, preventing out-of-bounds errors.
 
 6. Rule 11.1: Conversions between pointers to different object types are avoided.
    - The code does not perform any conversions between pointers to different object types.
 
 7. Rule 14.3: Controlling expressions are essentially Boolean.
    - All controlling expressions in if, while, and for statements are Boolean.
 
 8. Rule 15.1: All if...else if constructs are terminated with an else statement.
    - The code ensures that all if...else if constructs are properly terminated with an else statement.
 
 9. Rule 16.1: Functions with variable number of arguments are not used.
    - The code does not use any functions with a variable number of arguments.
 
 10. Rule 20.4: Dynamic heap memory allocation is avoided.
     - The code does not use dynamic heap memory allocation, ensuring better memory management.

 11. Rule 21.6: The Standard Input/Output library <stdio.h> is not used for output.
     - The code avoids using the <stdio.h> library for output operations.

     -The use of snprintf() is a deviation from these rule, as it is used to write formatted data to a string buffer.
      this is necessary for writing to the buffer in a safe and controlled manner.
 */
shared_memory_t cardata;
#define BUFFER_SIZE 256
char buffer[BUFFER_SIZE];

/**
 * @brief Signal handler for SIGINT.
 * 
 * This function handles the SIGINT signal (typically generated by pressing Ctrl+C).
 * It performs necessary cleanup operations such as unlocking the mutex, unmapping
 * the shared memory, and closing the file descriptor before exiting the program.
 * 
 * @param sig The signal number (in this case, SIGINT).
 */
void handle_sigint(int sig)
{
    snprintf(buffer, BUFFER_SIZE, "\nCaught signal %d, Dying\n", sig);
    write(STDOUT_FILENO, buffer, strlen(buffer));
    fflush(stdout);
    pthread_mutex_unlock(&cardata.data->mutex);
    munmap(cardata.data, sizeof(car_shared_data_t));
    close(cardata.fd);
    exit(EXIT_SUCCESS);
}

/**
 * @brief Validates if the given floor string is in a valid format.
 * 
 * This function checks if the provided floor string is valid. A valid floor string
 * can either start with 'B' followed by digits (e.g., "B1", "B2") or just digits 
 * (e.g., "1", "2"). The length of the floor string should not exceed 3 characters.
 * 
 * @param floor The floor string to be validated.
 * @return true if the floor string is valid, false otherwise.
 */
bool is_valid_floor(const char* floor) {
    if (floor[0] == 'B') {
        if (strlen(floor) > 3) {
            return false;
        }
        for (int i = 1; i < strlen(floor); i++) {
            if (!isdigit(floor[i])) {
                return false;
            }
        }
    } else {
        if (strlen(floor) > 3) {
            return false;
        }
        for (int i = 0; i < strlen(floor); i++) {
            if (!isdigit(floor[i])) {
                return false;
            }
        }
    }
    return true;  // Placeholder
}

/**
 * @brief This function processes the given input and performs the specified operation.
 * 
 * @param input The input data to be processed.
 * @param operation The operation to be performed on the input data.
 * @return The result of the operation performed on the input data.
 * 
 * @note Ensure that the input data is valid and the operation is supported.
 * 
 * @example
 * int result = functionName(inputData, operationType);
 * printf("Result: %d", result);
 */
bool is_valid_status(const char* status) {
    for (int i = 0; i < NUM_STATUSES; i++) {
        if (strcmp(status, status_names[i]) == 0) {
            return true;
        }
    }
    return false;
}




int main(int argc, char *argv[]){
    signal(SIGINT, handle_sigint);
    
    if (argc != 2) {
        fprintf(stderr, "Usage: %s {car name}\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    // // Validate name to ensure it only contains alphanumeric characters
    // for (int i = 0; argv[1][i] != '\0'; i++) {
    //     if (!isalpha(argv[1][i])) {
    //         fprintf(stderr, "Error: Name must only contain alphanumeric characters.\n");
    //         exit(EXIT_FAILURE);
    //     }
    // }
   

    char shm_name[256];
    snprintf(shm_name, sizeof(shm_name), "/car%s", argv[1]);
    if(get_shared_object(&cardata, shm_name) == false) {
        snprintf(buffer, BUFFER_SIZE, "Unable to access car %s\n", argv[1]);
        write(STDOUT_FILENO, buffer, strlen(buffer));
        fflush(stdout);
        memset(buffer, 0, BUFFER_SIZE);
        exit(EXIT_FAILURE);
    }

     

    while(true){
        pthread_mutex_lock(&cardata.data->mutex);
        pthread_cond_wait(&cardata.data->cond, &cardata.data->mutex);

        if (cardata.data->door_obstruction == 1 && strcmp(cardata.data->status, "Closing") == 0) {
        strcpy(cardata.data->status, "Opening");
        cardata.data->open_button = 1;
        //printf("Obstruction detected. Reopening doors.\n");
        }

        if (cardata.data->emergency_stop == 1 && cardata.data->emergency_mode == 0) {
            snprintf(buffer, BUFFER_SIZE, "The emergency stop button has been pressed!\n");
            write(STDOUT_FILENO, buffer, strlen(buffer));
            fflush(stdout);
            cardata.data->emergency_mode = 1;
        }

        if (cardata.data->overload == 1 && cardata.data->emergency_mode == 0) {
            snprintf(buffer, BUFFER_SIZE, "The overload sensor has been tripped!\n");
            write(STDOUT_FILENO, buffer, strlen(buffer));
            fflush(stdout);
            cardata.data->emergency_mode = 1;
        }

        if (cardata.data->emergency_mode != 1) {
            if (
                /*current_floor or destination_floor does not contain a valid floor string*/
                !is_valid_floor(cardata.data->current_floor) || 
                !is_valid_floor(cardata.data->destination_floor) ||

                /*status is not one of the 5 valid statuses*/
                !is_valid_status(cardata.data->status) ||

                /*uint8_t fields are 0 or 1*/
                cardata.data->open_button > 1 || cardata.data->close_button > 1 ||
                cardata.data->door_obstruction > 1 || cardata.data->overload > 1 ||
                cardata.data->emergency_stop > 1 || cardata.data->individual_service_mode > 1 ||

                /*door_obstruction is 1 and status is something other than Opening or Closing:*/
                (cardata.data->door_obstruction == 1 && 
                strcmp(cardata.data->status, status_names[Opening]) != 0 && 
                strcmp(cardata.data->status, status_names[Closing]) != 0)) 
            {
                snprintf(buffer, BUFFER_SIZE, "Data consistency error!\n");
                write(STDOUT_FILENO, buffer, strlen(buffer));
                fflush(stdout);
                cardata.data->emergency_mode = 1;
            }

            if (!is_valid_floor(cardata.data->current_floor) || !is_valid_floor(cardata.data->destination_floor))
                {snprintf(buffer, BUFFER_SIZE, "Floor consistency error!\n");
                write(STDOUT_FILENO, buffer, strlen(buffer));
                fflush(stdout);
                cardata.data->emergency_mode = 1;}
            if (!is_valid_status(cardata.data->status))
               {snprintf(buffer, BUFFER_SIZE, "Status consistency error!\n");
                write(STDOUT_FILENO, buffer, strlen(buffer));
                fflush(stdout);
                cardata.data->emergency_mode = 1;}
            if(cardata.data->open_button > 1 || cardata.data->close_button > 1 ||
                cardata.data->open_button > 1 || cardata.data->close_button > 1 ||
                cardata.data->door_obstruction > 1 || cardata.data->overload > 1 ||
                cardata.data->emergency_stop > 1 || cardata.data->individual_service_mode > 1){
                snprintf(buffer, BUFFER_SIZE, "Button consistency error!\n");
                write(STDOUT_FILENO, buffer, strlen(buffer));
                fflush(stdout);
                cardata.data->emergency_mode = 1;
                }

            if(
                (cardata.data->door_obstruction == 1 && 
                strcmp(cardata.data->status, status_names[Opening]) != 0 && 
                strcmp(cardata.data->status, status_names[Closing]) != 0)){
                snprintf(buffer, BUFFER_SIZE, "Door Status consistency error!\n");
                write(STDOUT_FILENO, buffer, strlen(buffer));
                fflush(stdout);
                cardata.data->emergency_mode = 1;
                } 
        }
        pthread_mutex_unlock(&cardata.data->mutex);
    }
    return 0;
}

